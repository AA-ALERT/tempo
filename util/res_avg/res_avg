#!/usr/bin/perl -w

# Average a date-sorted residual file to 1 point per day
# Expects input in the form produced by print_resid.
# Sample usage:
#   print_resid | res_avg

($dt, $df, $dfflag, $cflag) = &resavg_arg_parse(@ARGV);

&resavg_read;

$r2_tot = 0.0;
$wr2_tot = 0.0;
$wt_tot = 0.0;
$ct_tot = 0.0;

# Pop off the first residual, then search for any other residuals
# residuals that are within the desired time- and frequency ranges.
# Each residual is removed from the arrays as it is used. 
# When the arrays are empty, the program is done.

while ($#mjda>-1) {

  &resavg_clear_variables;

  # start with the first residual
  $mjdmin= $mjda[0];
  $mjdmax= $mjda[0];
  $freqmin = $freqa[0];
  $freqmax = $freqa[0];
  &resavg_use_residual(0);

  # loop through all other residuals
  # residuals are removed from the arrays as they are used
  # hence the loop structure for this process is a little convoluted
  $i = 0;
  while ($i<=$#mjda) {
    # is the residual within the desired time range (and optionally frequency range?)
    if (  $mjda[$i] >= $mjdmax-$dt &&
          $mjda[$i] <= $mjdmin+$dt &&
        ( !$dfflag  ||  $freqa[$i] >= (1.-$df)*$freqmax ) &&
        ( !$dfflag  ||  $freqa[$i] <= (1.+$df)*$freqmin ) ) {
      # process the residual
      &resavg_use_residual($i);
      # expand time or frequency range to include this residual
      $mjdmin = $mjd0 if ($mjd0<$mjdmin);
      $mjdmax = $mjd0 if ($mjd0>$mjdmax);
      $freqmin = $freq0 if ($freq0<$freqmin);
      $freqmax = $freq0 if ($freq0>$freqmax);
      # do not increment $i; 'splice' functions have put next residual into $i position
    } else {
      $i++   
    }
  }

  # process this batch of residuals (write out the averages, etc.)
  &resavg_calculate_print;
    
}

print sprintf("# WRMS = %.3f ns\n", sqrt($wr2_tot/$wt_tot));
print sprintf("#  RMS = %.3f ns\n", sqrt($r2_tot/$ct_tot));

#-----------------------------------------

sub resavg_arg_parse{

  # parse input line (see $usage below for details)
  #
  # the parsing code is set up to allow for:
  #    -- flags of the form '-a'
  #    -- flags with parameters of the form '-axxxx'
  #    -- parameters without flags, simply 'xxxx' (but see velow)
  #
  # Parameters without flags are accumulated in array @param.  Since the code
  # does not presently have any use for such parameters, this array is not returned
  # to the calling program.  Its length is checked and, if it has any entries, it
  # is flagged as an error.

  my($usage) = 
  "Use:\n".
  "  res_avg [flags]\n" .
  "Input:\n".
  "  time-sorted (optionally frequency-sorted as well) residuals in standard input\n".
  "Output:\n".
  "  list of date, frequency, residual, error, orbital phase, reduced chi^2\n".
  "Typical use:\n".
  "  for a single daily TOA: print_resid | res_avg\n".
  "  for one TOA per widely separated narrow band: print_resid | res_avg -f0.25\n".
  "Flags:\n".
  "  -c:    calculate weighted avg residual from fit of resid and dm at each epoch\n".
  "         (experimental!  use with care!)\n".
  "  -fxxx: maximum fractional frequency range, abs(f-f0)/f0, over which residuals\n".
  "         are averaged [default: not used]\n".
  "  -h   : help message\n".
  "  -txxx: maximum time (in days) over which residuals are averaged, [default: 1]\n"
;

  my($f);
  my($par);
  my(@param)=();
  
  # defaults
  
  my($dt) = 1;     # max time from first to last TOA in a single average (units=days)
  
  my($dfflag) = 0; # flag to produce separate averages for separate frequency ranges
  my($df) = 0.25;  # max fracional frequency difference (f-f0)/f0 in a single average

  my($cflag) = 0;  # calculate avg residual based on fit of both residual and dm
  
  foreach $par (@_) {
    if ($par=~/^-/) {           # flags
      $par = substr($par,1);      #   strip off the leading "-"
      while ($par ne "") {      #   loop through the string
        $f = substr($par,0,1);  #     strip off the current flag
        $par = substr($par,1);    #     process flags:
        if ($f eq "c")      {#       -c
          $cflag = 1;
        } elsif ($f eq "f") {#       -f
          $dfflag = 1;
          $df = $par;
          last;
        } elsif ($f eq "h") {#       -h
          die $usage;
        } elsif ($f eq "t") {#       -t
          $dt = $par;
          last;
        }  else {            #       invalid flag
          print "\nERROR: Invalid flag -$f\n\n";
          die $usage;
        }
      }
    } else {                  # parameters  
      push @param, $par;        #   push onto parameter list
    }
  }

  if ($#param>=0) {
    print "\nERROR: following parameters have no meaning: ",join(" ",@param),"\n";
    die $usage;
  }

return $dt, $df, $dfflag, $cflag;
}

#-----------------------------------------

sub resavg_clear_variables{
  $count = 0;
  $wtsum = 0;
  $r2sum = 0;
  $mjd = $freq = $res = $err = $ophase = 0.0;
  if ($cflag) {
    $ff   = 0;
    $ffff = 0;
    $ffres = 0;
  }
}


#-----------------------------------------

sub resavg_calculate_print{
  # Normalize avgs
  $mjd  /= $wtsum;
  $freq /= $wtsum;
  $res  /= $wtsum;
  $ophase /= $wtsum;
            # How to compute error....
  if ($count>1) { 
      $rchi2 = ($r2sum - $wtsum*$res*$res)/($count-1);
  } else {
      $rchi2 = 1.0;
  }
  $err = sqrt($err)/$wtsum;
  $err *= sqrt($rchi2);
  $wr2_tot += $res*$res*(1.0/($err*$err));
  $r2_tot += $res*$res;
  $wt_tot += (1.0/($err*$err));
  $ct_tot++;

  if ($cflag) {
    $a = $wtsum;
    $b = $ff;
    $c = $ff;
    $d = $ffff;
    $e = $res*$wtsum; # un-do normalization done a few lines above
    $f = $ffres;
    $rnew = ($e*$d-$b*$f)/($a*$d-$b*$c);
    $rnewerr = $d/($a*$d-$b*$c);  
  }

  printf "%15.9f %9.4f %+.8e %.4e %11.8f %10.4f",
      $mjd, $freq, $res, $err, $ophase, $rchi2;
  print printf "  %12.8f  %12.8f", $rnew, $rnewerr if ($cflag);
  print "\n";
}


#-----------------------------------------

sub resavg_read{
  # read data from standard input into a series of arrays
  # (this code really makes me appreciate perl lists)
  @mjda = ();
  @freqa = ();
  @resa = ();
  @erra = ();
  @ophasea = ();
  while (<STDIN>) {
    chomp;
    ($mjd0, $freq0, $res0, $err0, $ophase0) = split;
    push @mjda, $mjd0;
    push @freqa, $freq0;
    push @resa, $res0;
    push @erra, $err0;
    push @ophasea, $ophase0; 
  }
}

#-----------------------------------------

sub resavg_use_residual{
  # extract data for a single residual and accumulate it into sums

  my($idx) = $_[0];

  # pull values out of arrays

  $mjd0    = splice (@mjda   ,$idx,1);
  $freq0   = splice (@freqa  ,$idx,1);
  $res0    = splice (@resa   ,$idx,1);
  $err0    = splice (@erra   ,$idx,1);
  $ophase0 = splice (@ophasea,$idx,1);

  # calculate weight
  $wt0 = 1.0/($err0*$err0);

  # Add into sums
  $mjd += $mjd0*$wt0;
  $freq += $freq0*$wt0;
  $res += $res0*$wt0;
  $ophase += $ophase0*$wt0;
  $err += $err0*$err0*$wt0*$wt0;
  $r2sum += $res0*$res0*$wt0;
  $wtsum += $wt0;
  $count++;
  if ($cflag) {
    $ff    += ($freq0**-2)*$wt0;       # accumulate   1/f^2
    $ffff  += ($freq0**-4)*$wt0;       # accumulate   1/f^4
    $ffres += ($freq0**-2)*$res*$wt0;  # accumulate res/f^2
  }

}

